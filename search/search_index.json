{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"00%20-%20Overview/","text":"Minions is an extensible, MCP-compliant agentic AI framework written in Java and built using idiomatic Spring practices. Designed from the ground up with the principles of extensibility , traceability , and enterprise readiness , Minions provides a solid foundation for building and orchestrating autonomous AI agents in regulated and complex environments. At its core, Minions follows the Open/Closed Principle : the system is open for extension but closed for modification. Whether you're building a ReAct-style reasoning agent, a planner-executor-observer pipeline, or a bespoke recipe for your enterprise workflow, Minions enables it without changing the underlying framework. Why Minions? The AI ecosystem has rapidly shifted toward agentic workflows \u2014systems where autonomous agents reason, plan, act, and reflect over multiple steps. While many open-source frameworks offer this in Python, Minions is one of the few that brings this capability to the enterprise Java ecosystem with full support for: Spring Boot auto-configuration and injection Modular architecture that can be expanded with Spring Beans Privacy and governance by design Idiomatic support for lifecycle management, configuration, and testing Key Design Principles Extensibility First Minions uses design patterns like Definition/Customizer , Chain of Responsibility , and Factory Registry to allow seamless plug-in of new components\u2014steps, tools, memories, processors\u2014without modifying the core. Idiomatic Spring Integration The framework follows familiar Spring idioms, making it easy for developers to inject, override, and extend functionality using standard annotations and configuration mechanisms. MCP Compliance Minions adheres to the Model Connector Protocol (MCP) , enabling composability, cross-model interoperability, and architectural clarity. Enterprise-Grade Capabilities Features like memory privacy, audit hooks, multi-tenant memory isolation, and structured evaluation make Minions a suitable foundation for regulated industries like insurance, healthcare, and finance. Agent Recipes Every agent in Minions is instantiated from a Recipe . A recipe defines the agent\u2019s purpose and structure: Its system prompt and goal The step graph that outlines its thought/action flow Its memory strategy , specifying what the agent remembers and when Optional toolchains and observers Different types of recipes are available out-of-the-box, including: - ReActAgentRecipe - PlannerExecutorObserverRecipe - And more custom agent types We\u2019ll dive deeper into recipes, step graphs, and memory strategies in the following sections.","title":"Overview"},{"location":"00%20-%20Overview/#why-minions","text":"The AI ecosystem has rapidly shifted toward agentic workflows \u2014systems where autonomous agents reason, plan, act, and reflect over multiple steps. While many open-source frameworks offer this in Python, Minions is one of the few that brings this capability to the enterprise Java ecosystem with full support for: Spring Boot auto-configuration and injection Modular architecture that can be expanded with Spring Beans Privacy and governance by design Idiomatic support for lifecycle management, configuration, and testing","title":"Why Minions?"},{"location":"00%20-%20Overview/#key-design-principles","text":"Extensibility First Minions uses design patterns like Definition/Customizer , Chain of Responsibility , and Factory Registry to allow seamless plug-in of new components\u2014steps, tools, memories, processors\u2014without modifying the core. Idiomatic Spring Integration The framework follows familiar Spring idioms, making it easy for developers to inject, override, and extend functionality using standard annotations and configuration mechanisms. MCP Compliance Minions adheres to the Model Connector Protocol (MCP) , enabling composability, cross-model interoperability, and architectural clarity. Enterprise-Grade Capabilities Features like memory privacy, audit hooks, multi-tenant memory isolation, and structured evaluation make Minions a suitable foundation for regulated industries like insurance, healthcare, and finance.","title":"Key Design Principles"},{"location":"00%20-%20Overview/#agent-recipes","text":"Every agent in Minions is instantiated from a Recipe . A recipe defines the agent\u2019s purpose and structure: Its system prompt and goal The step graph that outlines its thought/action flow Its memory strategy , specifying what the agent remembers and when Optional toolchains and observers Different types of recipes are available out-of-the-box, including: - ReActAgentRecipe - PlannerExecutorObserverRecipe - And more custom agent types We\u2019ll dive deeper into recipes, step graphs, and memory strategies in the following sections.","title":"Agent Recipes"},{"location":"01%20-%20Core%20Concepts/","text":"Understanding the foundational elements of Minions is essential before diving into its deeper architecture. This section introduces the two most important constructs: Agents and Recipes . \ud83e\udde0 What is an Agent? In Minions, an Agent is an autonomous entity capable of executing a goal-driven process. It engages in multi-step reasoning, decision-making, and tool interaction. Each agent operates within a defined context, maintaining state across steps and coordinating its behavior using recipes, memory, and step graphs. \ud83d\udd04 Agent Lifecycle Initialization : The agent is instantiated from a recipe. This includes loading its system prompt, goal, memory configuration, and step graph. Goal Assignment : A goal is defined either at instantiation or injected dynamically (e.g., from user input or a higher-level planner). Step Execution : The agent traverses its step graph, making decisions, calling models, and interacting with tools as needed. Memory Update : After each step, the agent records new information, summarizes if needed, and updates relevant memories. Completion : The agent completes once the graph reaches a terminal node or a completion condition is met. Agents are MCP-compliant and traceable , allowing developers to monitor execution, review decision points, and integrate with observability tooling. \ud83c\udf73 What is a Recipe? A Recipe is a declarative blueprint for constructing an agent. Rather than configuring agents imperatively through code, developers define recipes that describe the agent\u2019s identity, structure, and behavior. A recipe includes: \u2705 System Prompt \u2013 The initial set of instructions or framing context for the agent\u2019s behavior. \ud83c\udfaf Goal \u2013 The task or objective the agent is trying to achieve. \ud83e\udde9 Step Graph \u2013 A flow structure of logical steps the agent executes in order, conditionally, or iteratively. \ud83e\udde0 Memory Strategy \u2013 Defines how the agent stores, summarizes, and retrieves contextual information across steps. \ud83d\udee0 Toolchain and Hooks (optional) \u2013 Tools the agent can call and hooks for evaluation, logging, or transformation. By encapsulating these into a recipe, Minions makes it easy to spin up different kinds of agents, each purpose-built for a use case, without rewriting orchestration logic.","title":"Core Concepts"},{"location":"01%20-%20Core%20Concepts/#what-is-an-agent","text":"In Minions, an Agent is an autonomous entity capable of executing a goal-driven process. It engages in multi-step reasoning, decision-making, and tool interaction. Each agent operates within a defined context, maintaining state across steps and coordinating its behavior using recipes, memory, and step graphs.","title":"\ud83e\udde0 What is an Agent?"},{"location":"01%20-%20Core%20Concepts/#agent-lifecycle","text":"Initialization : The agent is instantiated from a recipe. This includes loading its system prompt, goal, memory configuration, and step graph. Goal Assignment : A goal is defined either at instantiation or injected dynamically (e.g., from user input or a higher-level planner). Step Execution : The agent traverses its step graph, making decisions, calling models, and interacting with tools as needed. Memory Update : After each step, the agent records new information, summarizes if needed, and updates relevant memories. Completion : The agent completes once the graph reaches a terminal node or a completion condition is met. Agents are MCP-compliant and traceable , allowing developers to monitor execution, review decision points, and integrate with observability tooling.","title":"\ud83d\udd04 Agent Lifecycle"},{"location":"01%20-%20Core%20Concepts/#what-is-a-recipe","text":"A Recipe is a declarative blueprint for constructing an agent. Rather than configuring agents imperatively through code, developers define recipes that describe the agent\u2019s identity, structure, and behavior. A recipe includes: \u2705 System Prompt \u2013 The initial set of instructions or framing context for the agent\u2019s behavior. \ud83c\udfaf Goal \u2013 The task or objective the agent is trying to achieve. \ud83e\udde9 Step Graph \u2013 A flow structure of logical steps the agent executes in order, conditionally, or iteratively. \ud83e\udde0 Memory Strategy \u2013 Defines how the agent stores, summarizes, and retrieves contextual information across steps. \ud83d\udee0 Toolchain and Hooks (optional) \u2013 Tools the agent can call and hooks for evaluation, logging, or transformation. By encapsulating these into a recipe, Minions makes it easy to spin up different kinds of agents, each purpose-built for a use case, without rewriting orchestration logic.","title":"\ud83c\udf73 What is a Recipe?"},{"location":"02%20-%20Step%20Graph/","text":"A Step Graph defines the structured flow of logic an agent follows to reach its goal. Unlike ad hoc prompt chaining, Minions formalizes execution paths using a graph of steps connected by transitions. \ud83e\uddf1 Components Step : A unit of logic or decision. A step can invoke a model, execute a tool call, or make a transition decision. StepGraphDefinition : Declarative definition of steps and their transitions. TransitionStrategy : Defines how the agent determines the next step. Can be sequential, conditional, or dynamic. Start Step / Terminal Step : Every graph has an entry point and can define one or more terminal states. \ud83d\udd04 Step Execution Flow Agent starts at the defined start step. Executes step logic: e.g., prompts the model, triggers a tool, processes memory. Determines the next step using a transition strategy. Repeats until a terminal step is reached or a completion condition is satisfied. \ud83e\uddf0 Customizing Step Graphs Minions supports a Definition/Customizer pattern: Definition defines the logic and structure. Customizers allow injection of additional behavior, transitions, or overrides without modifying the core. This allows default agent flows to be extended in context-aware ways\u2014e.g., adding a retry step only in certain environments.","title":"Step Graph"},{"location":"02%20-%20Step%20Graph/#components","text":"Step : A unit of logic or decision. A step can invoke a model, execute a tool call, or make a transition decision. StepGraphDefinition : Declarative definition of steps and their transitions. TransitionStrategy : Defines how the agent determines the next step. Can be sequential, conditional, or dynamic. Start Step / Terminal Step : Every graph has an entry point and can define one or more terminal states.","title":"\ud83e\uddf1 Components"},{"location":"02%20-%20Step%20Graph/#step-execution-flow","text":"Agent starts at the defined start step. Executes step logic: e.g., prompts the model, triggers a tool, processes memory. Determines the next step using a transition strategy. Repeats until a terminal step is reached or a completion condition is satisfied.","title":"\ud83d\udd04 Step Execution Flow"},{"location":"02%20-%20Step%20Graph/#customizing-step-graphs","text":"Minions supports a Definition/Customizer pattern: Definition defines the logic and structure. Customizers allow injection of additional behavior, transitions, or overrides without modifying the core. This allows default agent flows to be extended in context-aware ways\u2014e.g., adding a retry step only in certain environments.","title":"\ud83e\uddf0 Customizing Step Graphs"},{"location":"03%20-%20Memory%20Management/","text":"Memory is a first-class concept in Minions. It gives agents the ability to remember context, recall facts, and summarize experiences across steps. \ud83e\udde9 Memory Types Chat Memory : Stores ongoing interactions (user, assistant, system messages). Step-local Memory : Temporary memory scoped to a single step. Long-Term Memory : Structured storage for facts, retrieved through semantic or attribute-based queries. \ud83e\uddea Memory Strategies Memory behavior is pluggable via MemoryStrategy interfaces: Append : Simply add new messages to memory. Windowed : Keep only the latest N messages. Summarize : Condense older memory into summaries. Flush and Rebuild : Clear old memory and retain only key state. You can define your own strategy by implementing MemoryStrategy<T extends ProcessContext> and wiring it via Spring. \ud83e\udde0 Memory Query DSL Minions provides a DSL to express queries over memory: MemoryQuery query = MemoryQuery.builder() .expression(ExprUtil.getUserMessagesExpression(\"C1\") .and(Expr.contains(\"content\", \"Hello\")) .and(Expr.metadata(\"entityType\", \"testEntity\"))) .limit(10) .build(); This allows agents to retrieve only relevant subsets of memory for each step.","title":"Memory Management"},{"location":"03%20-%20Memory%20Management/#memory-types","text":"Chat Memory : Stores ongoing interactions (user, assistant, system messages). Step-local Memory : Temporary memory scoped to a single step. Long-Term Memory : Structured storage for facts, retrieved through semantic or attribute-based queries.","title":"\ud83e\udde9 Memory Types"},{"location":"03%20-%20Memory%20Management/#memory-strategies","text":"Memory behavior is pluggable via MemoryStrategy interfaces: Append : Simply add new messages to memory. Windowed : Keep only the latest N messages. Summarize : Condense older memory into summaries. Flush and Rebuild : Clear old memory and retain only key state. You can define your own strategy by implementing MemoryStrategy<T extends ProcessContext> and wiring it via Spring.","title":"\ud83e\uddea Memory Strategies"},{"location":"03%20-%20Memory%20Management/#memory-query-dsl","text":"Minions provides a DSL to express queries over memory: MemoryQuery query = MemoryQuery.builder() .expression(ExprUtil.getUserMessagesExpression(\"C1\") .and(Expr.contains(\"content\", \"Hello\")) .and(Expr.metadata(\"entityType\", \"testEntity\"))) .limit(10) .build(); This allows agents to retrieve only relevant subsets of memory for each step.","title":"\ud83e\udde0 Memory Query DSL"},{"location":"04%20-%20Process%20Chains/","text":"Minions uses the Chain of Responsibility pattern to handle agent behaviors in a modular way. \ud83e\uddf1 Chains are used in: Step Completion Evaluation Memory Summarization Tool Selection Custom Output Evaluation Each chain is made of Processor<T extends ProcessContext> implementations that can be prioritized and conditionally applied. \ud83d\udee0 Defining a Processor @Component public class MaxModelCallCountProcessor extends AbstractProcessor<StepGraphCompletionContext<ProcessResult<StepCompletionOutcome>>, StepCompletionOutcome> { @Override public StepCompletionOutcome doProcess(StepGraphCompletionContext input) { // Custom logic } } Processors can expose Customizers to inject logic conditionally during Spring bootstrapping.","title":"Process Chains"},{"location":"04%20-%20Process%20Chains/#chains-are-used-in","text":"Step Completion Evaluation Memory Summarization Tool Selection Custom Output Evaluation Each chain is made of Processor<T extends ProcessContext> implementations that can be prioritized and conditionally applied.","title":"\ud83e\uddf1 Chains are used in:"},{"location":"04%20-%20Process%20Chains/#defining-a-processor","text":"@Component public class MaxModelCallCountProcessor extends AbstractProcessor<StepGraphCompletionContext<ProcessResult<StepCompletionOutcome>>, StepCompletionOutcome> { @Override public StepCompletionOutcome doProcess(StepGraphCompletionContext input) { // Custom logic } } Processors can expose Customizers to inject logic conditionally during Spring bootstrapping.","title":"\ud83d\udee0 Defining a Processor"},{"location":"05%20-%20Tool%20Integration/","text":"Agents often rely on tools to gather data, make external API calls, or trigger workflows. \ud83d\udd27 Defining a Tool A tool is a Spring Bean implementing Tool<TInput, TOutput> . It must define: The name and input schema Execution logic (usually async) Optionally: tool metadata and dynamic arguments \ud83e\udde0 Tool Usage Flow Step issues a tool call request. Tool resolves parameters and executes logic. Output is passed to the agent and can be stored in memory or used for reasoning.","title":"Tool Integration"},{"location":"05%20-%20Tool%20Integration/#defining-a-tool","text":"A tool is a Spring Bean implementing Tool<TInput, TOutput> . It must define: The name and input schema Execution logic (usually async) Optionally: tool metadata and dynamic arguments","title":"\ud83d\udd27 Defining a Tool"},{"location":"05%20-%20Tool%20Integration/#tool-usage-flow","text":"Step issues a tool call request. Tool resolves parameters and executes logic. Output is passed to the agent and can be stored in memory or used for reasoning.","title":"\ud83e\udde0 Tool Usage Flow"},{"location":"06%20-%20MCP%20Compliance/","text":"Minions adheres to the Model Connector Protocol (MCP) : Agent Recipes define system prompts and goals Step Graphs enable structured orchestration Memory strategies respect MCP\u2019s memory boundaries Tool calls are structured and interoperable This makes Minions compatible with emerging standards in agent orchestration and allows potential future interop with platforms like LangGraph.","title":"MCP Compliance"},{"location":"07%20-%20Spring%20Integration/","text":"Minions is built around idiomatic Spring patterns: Use @Component to register custom steps, processors, tools, strategies @ConfigurationProperties for loading recipe or agent configuration from YAML or application context Conditional wiring using Spring Boot's auto-config features You can fully extend Minions without modifying its internals, using standard Spring idioms.","title":"Spring Integration"},{"location":"08%20-%20Evaluation%20%26%20Observability/","text":"Minions supports observability hooks throughout the agent lifecycle: Step-level evaluations Memory inspection Custom evaluators for response scoring or compliance Audit trails and trace IDs Observers can be attached declaratively in recipes or dynamically at runtime.","title":"Evaluation & Observability"},{"location":"09%20-%20Privacy%20%26%20Governance/","text":"Minions was designed with regulated industries in mind. PII Filters : Redact or transform sensitive information before it enters models or tools. Multi-tenant Memory Isolation : Each tenant has scoped memory and tool access. Audit Hooks : Every agent action is traceable and timestamped. Local LLM Integration : Optional fallback to local models for privacy-sensitive steps.","title":"Privacy & Governance"},{"location":"10%20-%20Extending%20Minions/","text":"Minions is modular. You can extend it by: Creating new Step , Tool , Processor , or MemoryStrategy Defining new transition strategies Injecting custom evaluators, observers, filters Composing new AgentRecipe classes","title":"Extending Minions"},{"location":"11%20-%20Examples/","text":"ReAct Agent with Memory and Tools : A reasoning agent that reads from memory and calls external APIs. Planner with Conditional Branching : Plan, act, and re-evaluate based on tool outcomes. Privacy-Aware Agent : Uses filters to redact user PII before prompting the model.","title":"Examples"},{"location":"12%20-%20Testing%20%26%20Debugging/","text":"Unit test Steps, Recipes, and Chains using JUnit + Spring Boot Test Mock model responses and tool outputs View memory snapshots between steps Trace execution via built-in logging topics","title":"Testing & Debugging"},{"location":"13%20-%20Roadmap%20%26%20Contribution/","text":"Support for Google A2A multi-agent protocol Visual step graph debugger RAG-native agent types Python bridge (interop with LangChain tools) Contributions welcome via GitHub","title":"Roadmap & Contribution"},{"location":"_Index/","text":"\ud83d\udcda Minions Developer Documentation Welcome to the official developer documentation for the Minions Framework. \ud83d\udcd1 Table of Contents [[00 - Overview|Overview]] [[01 - Core Concepts|Core Concepts]] [[02 - Step Graph|Step Graph]] [[03 - Memory Management|Memory Management]] [[04 - Process Chains|Process Chains]] [[05 - Tool Integration|Tool Integration]] [[06 - MCP Compliance|MCP Compliance]] [[07 - Spring Integration|Spring Integration]] [[08 - Evaluation & Observability|Evaluation & Observability]] [[09 - Privacy & Governance|Privacy & Governance]] [[10 - Extending Minions|Extending Minions]] [[11 - Examples|Examples]] [[12 - Testing & Debugging|Testing & Debugging]] [[13 - Roadmap & Contribution|Roadmap & Contribution]]","title":"\ud83d\udcda Minions Developer Documentation"},{"location":"_Index/#minions-developer-documentation","text":"Welcome to the official developer documentation for the Minions Framework.","title":"\ud83d\udcda Minions Developer Documentation"},{"location":"_Index/#table-of-contents","text":"[[00 - Overview|Overview]] [[01 - Core Concepts|Core Concepts]] [[02 - Step Graph|Step Graph]] [[03 - Memory Management|Memory Management]] [[04 - Process Chains|Process Chains]] [[05 - Tool Integration|Tool Integration]] [[06 - MCP Compliance|MCP Compliance]] [[07 - Spring Integration|Spring Integration]] [[08 - Evaluation & Observability|Evaluation & Observability]] [[09 - Privacy & Governance|Privacy & Governance]] [[10 - Extending Minions|Extending Minions]] [[11 - Examples|Examples]] [[12 - Testing & Debugging|Testing & Debugging]] [[13 - Roadmap & Contribution|Roadmap & Contribution]]","title":"\ud83d\udcd1 Table of Contents"}]}